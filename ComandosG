Comandos básicos de bash:

-ls = Lista el contenido de un directorio actual de trabajo. También se puede especificar un directorio en 
particular. Por ejemplo: ls /home
-ls -a = Se lista todos los contenidos del directorio actual o especificado, incluyendo los archivos ocultos.
-ls -l = Listado completo de información (el parámetro "l" se puede combinar con otros parámetros útiles). 
-ls -d = Listar los directorios en vez de dentro de ellos.
-cd = cambiar de directorio, cd .. = retroceder un directorio
-cp = copiar archivos.
-dir = parecido a ls.
-mkdir = crea una carpeta
-mv = mover archivos y carpetas, ejemplo = mv archivo /home/kevinc-debian/Documentos/
-rmdir = eliminar un directorio vacio
-exit = salir de una sesion de terminal
-login = iniciar sesion en terminal, OJO: DEBE SER ROOT
-su = Iniciar sesion como superusuario
-sudo = ejecutar comandos directamente como root
-rm = eliminar un archivo, rm -r = elimina directorios y ficheros
-more = ver el contenido de un archivo, paso a paso
-cat = ver el contenido de un archivo, de una vez
-touch = Actualiza los registros de fecha y hora, con la fecha y hora actual de los ficheros indicados como argumento, además, si el fichero no existe, el comando touch lo crea. Su uso más frecuente es para crear archivos
-man = ver el manual de un comando
-chmod = Cambia permisos de un archivo o directorio
-chmod -R = Cambia permisos de un directorio recursivamente
-clear = limpiar/despalazar pantalla
-who = mostrar los usuarios que han iniciado sesion
-whoami = mostrar el usuario actual en sesion
-nano = Editor de texto, se debe colocar el direcortio del archivo, excepto si la consola ya esta en ese directorio

===========================================================================================================================================================

Permisos de archivos:
comando utilizado = chmod

       ref A
r (read) = lectura : 4
w (write) = Escritura: 2
x (execute) = Ejecutable: 1

       ref B
rwx = propetario = u
rwx = grupo      = g
rwx = otros      = o

Ejemplo:

Dar permisos;
chmod u+rwx nombre_del_archivo ó chmod u=rwx nombre_del_archivo
Quitar permisos:
chmod u-rwx nombre_del_archivo

Segundo ejemplo:

Al haber solo 3 posibles valores de permisos que se le pueden asignar a los archivos, ya sea escritura, lectura y ejecucion
las posibilidades que pueden tener esta definido por 2*3 = 8 posibilidades, entonces el comando chmod se puede
utilizar de manera octal para los 3 tipos de ususarios, definidos en la ref B
el valor en octal para cada permiso tiene un valor en octal definido en la ref A, donde lectura tiene el valor de 4,
entonces si se quiere dar permiso de escritura y lectura al propetario, se debe utilizar chmod 4 + 2 = 6 => chmod 6, que es la suma del valor
en octal del permiso de escritura y lectura para el propetario, ademas se pueden dar los permisos a los grupos y otros colocando en el mismo comando, 
es decir, si se quiere dar permiso a un grupo de solo lectura se debe hacer de la siguente manera chmod 64, el valor de lectura que es 4, va despues del
valor del permiso del propetario, de igual forma sucede con otros, el valor va despues de grupo, por ejemplo se quiere asignar el valor de solo lectura
y ejecucion a otros, se debe hacer de la siguiente forma chmod 645

OJO: Una carpeta debe tener permiso de ejecucion para abrir, en forma contraria un archivo si se abrir con solo el permiso de lectura

==========================================================================================================================================================

Herramientas de administracon de software APT:
apt-get install, remove, purge, upgrade, update, dist-upgrade, apt-cache search

================================================================================
Comprimir archivos

rar a nombre.rar ficheros

================================================
Descomprimir archivos 

tar -zxvf nombre.tar.gz
tar -jxvf nombre.tar.bz2
unzip nombre.zip
unrar x archivo.rar
tar -Jxvf nombre.tar.xz ó tar -xvf nombre.tar.xz

==================================================================================================================

Ejecutar script de python2 o 3 en el shell:

1) Crear el nombre del archivo con el comando:

touch nombredelarchivo.py

2) Luego, darle los permisos de lectura ejecucion y escritura. ejemplo

chmod 7 nombredelarchivo.py ó chmod 777 nombredelarchivo.py ó chmod +xwr nombredelarchivo.py

3) Despues de crear el archivo con los permisos de ejecucion, escritura y lectura se debe colocar en la primera linea del archivo de python la siguiente
ruta:

#!/usr/bin/python ó #!/usr/bin/python2 ó  #!/usr/bin/python3

Si se desconoce la direccion del interprete, ejecute el siguiente comando:

which python

Ese comando indicará la direción del interprete

4) Después de tener todo el programa listo, se debe ejecutar con el siguiente comando:

./nombredelarchivo.py ó python nombredelarchivo.py

Y listo. 

==========================================================================================================================================================

Compilar y ejecutar programas en C.

1) Crear el archivo con su extension y darle los permisos de escritura, lectura y ejecucion, siguiendo la misma forma que python.
2) Editar y crear el codigo fuente.
3) Luego de tener el codigo se procede a compilar, utilizando el siguiente comando:
gcc script.c -o nombredesalida    también   gcc script.c -o nombredesalida -Wall -pedantic

el segundo comando es para que se den detalles y errores al momento de compilar el script

4) luego de compilar y tener el nombre del ejecutable, el script se ejecuta con el siguiente comando:

./nombredesalida

y listo se ejecuta el script programado.

============================================================================================================================================================
Agregar direcciones a la variable de entorno PATH

1) Primera Forma:

Agregar el directorio a la variable PATH con el siguiente comando de ejemplo:


echo 'export PATH=$PATH:/home/kevinc-debian/"programa_ejecutable ó solo la direccion donde se encuentra"' >> /home/kevinc-debian/.bashrc

y listo.

2) Segunda forma:

Editar el archivo .bashrc con cualquier editor de texto, ya sea nano o gedit, y dirigirse a la ultima linea y colocar la direccion donde se encuentra
el archivo de preferencia.

EJEMPLO:

1) echo 'export PATH=$PATH:/home/kevinc-debian/Documentos/sublime_text_3/' >> /home/kevinc-debian/.bashrc

2)- nano /home/kevinc-debian/.bashrc
- Dirigirse a la ultima linea del Programa y copiar: export PATH=$PATH:/home/kevinc-debian/Documentos/sublime_text_3/

=======================================================================================================================================================
CONEXIÓN REMOTA VIA SSH:

1)Instalar ssh con el siguiente comando: apt-get install openssh-server 
2)Para conectarse remotatemente via ssh, debe ejecutar el siguiente comando:

ssh nombredeusuario@direccionip, luego ingresar contraseña de usuario. EJEMPLO:

ssh kevin-debian@192.168.1.7
Ingresar contraseña: XXXXXX

3) Copiar archivos, importar y exportar:

Para exportar:

scp archivo.txt nombredeusuario@direccion_ip:/home/nombredeusuario

EJEMPLO:

scp archivo.txt kevin-debian@192.168.1.7:/home/kevin-debian/

Para importar:

scp nombredeusuario@direccion_ip:/home/nombredeusuario/archivo.txt /home/este_usuario/Carpeta 

EJEMPLO:

scp kevin-debian@192.168.1.7:/home/kevin-debian/archivo.txt /home/kevinc-debian/Documentos

4) Copiar directorio completo:

scp -r /home/este_equipo/carpeta nombredeusuario@direccion_ip:/home/nombredeusuario

================================================================================================
Instalar driver:

1) Primera forma:

Descargar el driver y copiarlo en el siguiente directorio:

/lib/firmware

===========================================================
Abrir un archivo en PDF

Ejecutar el siguiente comando:

evince nombredelarchivo.pdf

==========================================
Para ver que shell está en uso: 

Utilizar el comando "echo $SHELL"

Para ver la versión del shell bash:

Utilizar el comando '/bin/bash --version'

=================================================================================================================
Iniciar bootear un dispositivo USB desde Grub2

Primero presionar la letra "c" cuando aparezca el prompt de grub, luego utilizar los siguientes comandos:

set root=(hdN)        <"Pulsando TAB después de '(hd' se listarán todos los dipositivos del sistema."
chainloader +N         "Usar esto para verificar el número que le corresponde al dispositivo USB, desconectando"
boot                   "reiniciando, verificando, conectando otra vez, y verificando otra vez.">

Donde "N" es la enumeración de dispositivo de almacenamiento que se encuentra conectado a los perifericos del PC. 

Ejemplos:
 
*Disco Duro (Todo el disco duro, no se toman en cuenta las particiones) = hd0.
*Pendrive USB = hd1.
*Pendrive USB2 = hd2.

OJO = hd0, es "casi siempre" donde se inicia grub.

=================================================================================================================
Instalación y uso de servidor FTP (ProFTPD) "Básico"

apt-get install proftpd-basic proftpd-doc

Luego abrir con un editor de texto el archivo de configuración ubicado en la ruta: /etc/proftpd/proftpd.conf

Si el servidor va a utilizar la IPv4, entonces se debe desactivar el soporte para la IPv6 en una
linea parecida a la siguiente:

#[...]
# Set off to disable IPv6 support which is annoying on IPv4 only boxes.
UseIPv6                         off
#[...]

Luego, verificar que el servidor esté configurado como "standalone" como en la siguiente linea:

#[...]
ServerName                      "Debian"
ServerType                      standalone
DeferWelcome                    off
#[...]

OJO: Cada cambio hará efecto luego de reiniciar el servidor 
con el siguiente comando: /etc/init.d/proftpd restart

Para limitar el acceso sólo al directorio inicial, establecer tal ruta en la línea DefaultRoot:

# Use this to jail all users in their homes
DefaultRoot                     /

Posteriormente, crear un usuario para que tenga acceso al servidor, pero primero se debe asegurar que esté 
insertado /bin/false en /etc/shells. Si no está, utilizar el siguiente comando para insertarlo:

echo '/bin/false' >> /etc/shells ó echo "/bin/false" >> /etc/shells

ESTO CON LA INTENCIÓN DE QUE EL USUARIO QUE ESTE INTERACTUANDO CON EL SERVIDOR Y QUIERA INICIAR SESIÓN
EN EL SHELL, LE DEVUELVA FALSE E INMEDIATAMENTE NIEGA EL PERMISO PARA PODER INGRESAR.

Ya listo, ahora se debe crear el usuario con el siguiente comando:

adduser user1 --shell /bin/false --home /home/user1

Donde "user1" es el nombre que tendrá el nuevo usuario y "/home/user1" es el directorio donde estará su 
sistema de ficheros.

En el prompt que aparece, se debe indicar la contraseña y otros datos relacionados con el perfil del usuario.

Seguidamente añadir en el archivo de configuración /etc/proftpd/proftpd.conf el perfil para el cliente FTP
recien creado de la siguiente manera:

<Directory /home/user1>
  Umask 022 
  AllowOverwrite off
  <Limit LOGIN>
    AllowUser user1
    DenyAll
  </Limit>
  <Limit ALL>
    AllowUser user1
    DenyAll
  </Limit>
</Directory>

Donde "Directory /home/user1" es el directorio donde está el sistema de ficheros del usuario
y "AllowUser user1" debe ser remplazado por el nombre del usuario.

Después de que todos los datos fueron modificados según los deseados, se debe reiniciar el servicio
del servidor FTP con el siguiente comando: 

/etc/init.d/proftpd restart

Se puede consultar que usuarios están conectados al servidor FTP en tiempo real con los siguientes comandos:

ftpwho
ftptop

Más información para configuraciones mas específicas y completas en las siguientes páginas web:

https://www.ionos.es/digitalguide/servidores/configuracion/servidor-ftp-en-debian/
https://servidordebian.org/es/squeeze/internet/ftp/start
http://jcnicaro.cubava.cu/2017/10/13/instalar-y-configurar-un-servidor-ftp-en-debian/

==============================================================================================================

Reparar un disco duro con badblocks

Verificar primero el hdd que se desea reparar con fdisk, además, es recomendable desmontar el hdd del sistema
y luego ejecutar el siguiente comando:

badblocks -svnf /dev/sdX

Donde: 

-s: Se visualiza el escaneo del disco, y se muestra el proceso a base a porcentaje del 100%.
-v: Se activa el modo verboso, para mostrar los errores encontrados.
-n: Indica que se reparen los sectores en un modo no destructivo, y así evitar la perdida de información.
-f: Permite forzar la lectura y escritura en dispositivos que están montados.

==============================================================================================================

Dependencias incumplidas. Intente «apt --fix-broken install» sin paquetes (o especifique una solución)

======================================================================================================

Eliminar un usuario y sus achivos

deluser --remove-home usuario

============================================================

Saber que versión de Debian está instalada en la PC o laptop

Comando: lsb_release -a

===============================================================================================================

Repositorios (Información básica "MEJORAR")

Se puede añadir un repositorio en el archivo "/etc/apt/sources.list" o 
se puede crear un archivo *.list en el directorio "/etc/apt/sources.list.d/" con la información correspondiente.


Ejemplo (OPCIÓN 1):

root@Kevin-Debian:~# cat /etc/apt/sources.list

#deb cdrom:[Debian GNU/Linux 9.6.0 _Stretch_ - Official amd64 NETINST 20181110-11:34]/ stretch main

#deb cdrom:[Debian GNU/Linux 9.6.0 _Stretch_ - Official amd64 NETINST 20181110-11:34]/ stretch main

deb http://deb.debian.org/debian/ stretch main
deb-src http://deb.debian.org/debian/ stretch main

deb http://security.debian.org/debian-security stretch/updates main
deb-src http://security.debian.org/debian-security stretch/updates main

# stretch-updates, previously known as 'volatile'
deb http://deb.debian.org/debian/ stretch-updates main
deb-src http://deb.debian.org/debian/ stretch-updates main

deb http://ftp.debian.org/debian/ unstable main contrib non-free

.............................................................
deb https://dl.winehq.org/wine-builds/debian/ stretch main
.............................................................


Ejemplo (OPCIÓN 2):

root@Kevin-Debian:~# ls /etc/apt/sources.list.d/
wine.list
root@Kevin-Debian:~# cat /etc/apt/sources.list.d/wine.list
............................................................. 
deb https://dl.winehq.org/wine-builds/debian/ stretch main
.............................................................

================================================================================================================
Comando tee:

Permite guardar la salida de un comando en un archivo, y también imprime la misma salida por pantalla.

Su uso se debe combinar con una tuberia "|" para pasarle el resultado que debe imprimir por pantalla cualquier
comando, como parámetro al comando tee. Ejemplo:

ls -l | tee file.txt

Si por alguna razón el archivo file.txt tiene datos que no se desean sobrescribir, se puede usar el parámetro
"--append" para que la salida sea copiada después de los datos que estaban escritos. Ejemplo: 

ls -l | tee --append file.txt

================================================================================================================

Comando "dd" (data duplicator = duplicador de datos):

dd if=input_data of=output_data [options]

input_data y output_data pueden ser discos, particiones, archivos, dispositivos, entre otros.

Ejemplos:


dd if=/dev/urandom of=/dev/sda bs=4k -» Llena el disco con datos aleartorios

dd if=/dev/sda of=/dev/sdb bs=4096 -» Duplicación disco-a-disco

dd if=/dev/zero of=/dev/sda bs=4k -» Limpia un disco duro (puede necesitar ser repetido)

dd if=/dev/sda | hexdump -C | grep [^00] -» Verifica si el disco está realmente puesto a cero

dd if=/dev/urandom of=/home/$user/hugefile bs=4096 -» Llena una partición (¡Cuidado con las particiones de 
sistema!)

dd if=/dev/urandom of=myfile bs=6703104 count=1 -» Codifica un archivo (tal vez antes de borrarlo)

dd if=/dev/sda3 of=/dev/sdb3 bs=4096 conv=notrunc,noerror -» Copia una partición hacia otra partición

dd if=/proc/filesystems | hexdump -C | less -» Visualiza los sistemas de ficheros disponibles

dd if=/proc/partitions | hexdump -C | less -» Visualiza las particiones disponibles en kb

dd if=/dev/sdb2 ibs=4096 | gzip > partition.image.gz conv=noerror -» Crea una imagen gzip de la segunda 
partición del segundo disco

dd bs=10240 cbs=80 conv=ascii,unblock if=/dev/st0 of=ascii.out -» Copia el contenido de una cinta a un archivo
convirtiendo de EBCDIC a ASCII

dd if=/dev/st0 ibs=1024 obs=2048 of=/dev/st1 -» Copia de un dispositivo de bloques de 1KB a un dispositivo de 
bloques de 2KB

dd if=/dev/zero of=/dev/null bs=100M count=100
100+0 records in
100+0 records out
10485760000 bytes (10 GB) copied,

5.62955 s, 1.9 GB/s

Copia 10 GB de ceros a la papelera de reciclaje.

dd if=/dev/zero of=/dev/sda bs=512 count=2
fdisk -s /dev/sda
dd if=/dev/zero of=/dev/sda seek=(number_of_sectors – 20) bs=1k

Borra GPT del disco. Como GPT escribe los datos al principio
Y al final del disco, después de borrar desde el principio, tenemos que encontrar el número de 
sectores (el segundo comando), y entonces borrar los 20 últimos sectores.

dd if=/home/$user/bootimage.img of=/dev/sdc -» Crea un disco UDB booteable (mostrado aquí como /dev/sdc)

dd if=/dev/sda of=/dev/null bs=1m -» Una buena manera de buscar bloques malos. Relacionados con respaldos 
y sistemas

dd if=/dev/sda of=/dev/fd0 bs=512 count=1 -» Copia el MBR a un disco flexible

dd if=/dev/sda1 of=/dev/sdb1 bs=4096 -» Duplicación disco-a-disco

dd if=/dev/sr0 of=/home/$user/mycdimage.iso\ bs=2048 conv=nosync -» Crea una imagen de un CD

mount -o loop /home/$user/mycdimage.iso /mnt/cdimages/ -» Monta localmente la imagen mencionada

dd if=/dev/sda of=/dev/sdb bs=64k conv=sync -» Útil cuando se reemplaza un disco por otro de idéntico tamaño.

dd if=/dev/sda2 of=/home/$user/hddimage1.img bs=1M count=4430
dd if=/dev/sda2 of=/home/$user/hddimage2.img bs=1M count=8860
[…]

Crea imágenes en DVD de una partición (útil para hacer respaldos)

dd if=/$location/hddimage1.img of=/dev/sda2 bs=1M
dd if=/$location/hddimage2.img of=/dev/sda2 seek=4430 bs=1M
dd if=/$location/hddimage3.img of=/dev/sda2 seek=8860 bs=1M
[etc…]

Restaura del respaldo anterior

dd if=/dev/zero count=1 bs=1024 seek=1 of=/dev/sda6 -» Destruye el superbloque

dd if=/dev/zero count=1 bs=4096 seek=0 of=/dev/sda5 -» Otra forma de destruir el superbloque

dd if=/home/$user/suspicious.doc | clamscan -» Verifica el archivo en busca de virus (necesita ClamAV)

dd if=/home/$user/binary file | hexdump -C | less -» Ver el contenido de un archivo binario (necesita hexdump)

dd if=/home/$user/bigfile of=/dev/null
dd if=/dev/zero of=/home/$user/bigfile bs=1024 count=1000000

Realiza un benchmark de la velocidad de lectura/escritura del disco duro

dd if=/dev/sda of=/dev/sda -» Da nueva vida a viejos discos duros que no han sido usados por un tiempo 
(los discos deben estar “unmounted”)

dd if=/dev/mem | strings | grep ‘string_to_search’ -» Examina el contenido de la memoria 
(legible para humanos, es decir)

dd if=/dev/fd0 of=/home/$user/floppy.image bs=2x80x18b conv=notrunc -» Copia un disco flexible

dd if=/proc/kcore | hexdump -C | less -» Muestra la memoria virtual

dd if=/proc/filesystems | hexdump -C | less -» Visualiza los sistemas de ficheros disponibles

dd if=/proc/kallsyms | hexdump -C | less -» Muestra los módulos cargados

dd if=/proc/interrupts | hexdump -C | less -» Muestra la tabla de interrupciones

dd if=/proc/uptime | hexdump -C | less -» Muestra el tiempo de actividad en segundos

dd if=/proc/partitions | hexdump -C | less -» Visualiza las particiones disponibles en kb

dd if=/proc/meminfo | hexdump -C | less -» Muestra el estado de la memoria

dd if=/dev/urandom of=/home/$user/myrandom bs=100 count=1 -» Crea un archivo de 1kb de jerigonza aleatoria

dd if=/dev/mem of=/home/$user/mem.bin bs=1024 -» Crea una imagen del estado actual de la memoria del sistema

dd if=/home/$user/myfile -» Imprime el archivo a stdout

dd if=/dev/sda2 bs=16065 | hexdump -C | grep ‘text_to_search’ -» Busca una cadena en una partición entera; 
incluso si está asegurada, usted puede bootear un liveCD

dd if=/home/$user/file.bin skip=64k bs=1 of=/home/$user/convfile.bin -» Copia file.bin a convfile.bin 
saltándose los primeros 64 kb

dd if=/home/$user/bootimage.img of=/dev/sdc -» Crea un disco UDB booteable (mostrado aquí como /dev/sdc)

dd if=/dev/mem bs=1k skip=768 count=256 2>/dev/null | strings -n 8 -» Lee la BIOS.

dd bs=1k if=imagefile.nrg of=imagefile.iso skip=300k -» Convierte una imagen de Nero en una imagen 
ISO estándar. Esto es posible porque la única diferencia entre las dos son los 300 kB de encabezamiento 
que Nero adiciona a una imagen ISO estándar.

echo -n “hello vertical world” | dd cbs=1 conv=unblock 2> /dev/null -» Inténtalo, es seguro.

dd if=/dev/sda1 | gzip -c | split -b 2000m – \ /mnt/hdc1/backup.img.gz -» Crea una imagen gzip de una 
partición utilizando división

cat /mnt/hdc1/backup.img.gz.* | gzip -dc | dd of=/dev/sda1 -» Restaura el respaldo anterior

dd if=/dev/zero of=myimage bs=1024 count=10240 -» Crea una imagen vacía del disco

dd ibs=10 skip=1 -» Divide los primeros 10 bytes de stdin

dd bs=265b conv=noerror if=/dev/st0 of=/tmp/bad.tape.image -» Hace una imagen de una cinta con sitios malos

dd if=/dev/sda count=1 | hexdump -C -» Visualiza su MBR

dd if=/dev/sda | nc -l 10001 nc $system_to_backup_IP 10001 | dd of=sysbackupsda.img -» Respaldo rápido de 
la red usando netcat

dd if=/dev/zero of=/dev/sdX bs=1024000 count=1 -» Limpia los primeros 10MB de la partición

dd if=/dev/zero of=tmpswap bs=1k
count=1000000
chmod 600 tmpswap
mkswap tmpswap
swapon tmpswap

Crea un espacio temporal de intercambio

dd if=/dev/sda of=/dev/null bs=1024k count=1024
1073741824 bytes (1.1 GB) copied,
24.1684 s, 44.4 MB/s

Determina la velocidad secuencial de I/O de su disco.

dd if=/dev/random count=1 2>/dev/null | od -t u1 |\ awk ‘{ print $2}’ | head -1 -» Genera un número aleatorio

dd if=/dev/mem of=myRAM bs=1024 -» Copia la memoria RAM hacia un archivo

dd if=/dev/sda bs=512 count=1 | od -xa -» Ver el contenido de su MBR en formato hex y ASCII

dd if=/my/old/mbr of=/dev/sda bs=446 count=1 -» Restaura el MBR sin alterar el registro de la tabla de 
partición el cual está entre 447 – 511 bytes

dd if=/dev/sda1 | split -b 700m – sda1-image -» Crea una copia de la partición y salva imágenes donde el 
tamaño máximo del volumen es 700MB

ls -l | dd conv=ucase -» Convierte la salida de un comando en mayúsculas

echo “MY UPPER CASE TEXT” | dd conv=lcase -» Convierte cualquier texto a minúsculas

dd if=/etc/passwd cbs=132 conv=ebcdic of=/tmp/passwd.ebcdic -» Convierte el archivo de contraseñas del sistema
a un archivo de longitud fija de formato EBCDIC

dd if=text.ascii of=text.ebcdic conv=ebcdic -» Convierte de ASCII a EBCDIC

dd if=myfile of=myfile conv=ucase -» Convierte un archivo a mayúsculas (simple SED o reemplazo tr)
==============================================================================================================

Dar formato a un pendrive USB (Versión Simple)

En primer lugar el pendrive USB debe estar desmontado, se puede usar el comando umount para realizar dicha 
acción. Ejemplo: umount /dev/sdX ó umount /media/PUNTODEMONTAJE

1) Limpiar el pendrive USB (OPCIONAL)

dd if=/dev/zero of=/dev/sdX bs=4k -> Limpia un disco duro (puede necesitar ser repetido)
dd if=/dev/sda | hexdump -C | grep [^00] -> Verifica si el disco está realmente puesto a cero

2) Crear una partición con el comando fdisk. Ejemplo de comando:

fdisk /dev/sdX -> Seguir los pasos del comando. 

Para obtener información de las opciones de fdisk, introducir "m", para eliminar una partición,
introducir "d", para crear una partición, introducir "n"

3) Dar formato a la partición con mkfs 

mkfs.vfat -F 32 /dev/sdX -n nombre_del_dispositivo

Donde mkfs.vfat, es el comando de mkfs para establecer un formato FAT, el parámetro "-F 32" establece el tipo
de formato Fat32 y "/dev/sdX" es el dispositivo, y "-n nombre_del_dispositivo" es el nombre que obtendra el
pendrive.

============================================================================================================

Copiar un texto o archivo de texto en el portapeles

Comando usado: xclip

Instalación apt-get install xclip

Ejemplo 1:
echo 'Prueba 1' | xclip -selection clipboard     ó    echo 'Prueba 1' | xclip -selection c

Ejemplo 2: (OJO SOLO COPIA LO QUE ESTÁ DENTRO DEL FICHERO DE TEXTO, NO EL ARCHIVO "texto.txt" LITERAL)
xclip -selection clipboard texto.txt     ó     xclip -selection c texto.txt

xclip -se c -> Está seria la manera mas corta de escribir el comando "-se" es la abstracción de -selection
y "c", la abstracción de clipboard.

Ejemplo 3:
ls -l | xclip -se c     ó     ls -l | xclip -selection clipboard

===========================================================================================================

Comando "du" (MEJORAR): Informa la cantidad de espacio de disco usado por los ficheros especificados.

OJO, si no se especifica un fichero, "du" realiza el chequeo en el directorio actual (pwd).

Ejemplo:

du -skh /home/

Dónde los parámetros:

-s = Muestra el total del directorio especificado y no recursivamente dentro de cada fichero 
dentro de él.

-k = Expresa la salida en bloques de 1024 bytes.

-h = Muestra la sálida para su fácil lectura legible.

Información completa en: man du
============================================================================================================

				Cambiar propietarios de archivos y directorios:

Cambiar propietario de un archivo:

chown usuario archivo.txt

Cambiar propietario de forma recursiva (carpeta):

chown -R usuario /carpeta

Cambiar usuario y grupo de un archivo:

chown usuario:grupo archivo.txt

Cambiar usuario y grupo de forma recursiva (carpeta):

chown -R usuario:grupo /carpeta

============================================================================================================

Ver los procesos que corren con su nombre y PID:

netstat -pant

============================================================================================================

		Enviar señales a los procesos corriendos en el sistema operativo:

Sintaxis:

kill SIGNAL PID

Ejemplo:

kill -9 564

kill -l 	//Para ver el valor numerico realcionado al nombre de la señal

Los cuales son estos:

 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	

Otra forma de detener un proceso es con el siguiente comando:

service 'service_name' stop

============================================================================================================

					Eliminar un paquete

De la manera simple (conociendo el nombre del paquete):

apt remove nombre_del_paquete

Alternativamente, si necesitamos eliminar el paquete junto con los archivos de configuración asociados entonces se usará:

apt --purge remove nombre_del_paquete

Si no conocemos el nombre del paquete a desinstalar, pero tenemos algún indicio de como comienza el nombre, así está a nuestro alcance usar el comando:

apt remove paquete* 
ó
apt-get purge paquete*


Desinstalando manualmente:

Lo primero que requerimos es la lista de paquetes instalados por apt:

apt list

Si encontramos una regualidad, sólo como ejemplo, paquetes que se inicien con el string php5 entonces podremos preparar la lista de ellos en un formato apropiado usando el comando:

apt list | grep '^paquete' | awk '{print $1}' FS="/" | tr "\n" " "
Ahora si vínculamos la salida del comando anterior al comando de desinstalación:

apt remove `apt list | grep '^paquete' | awk '{print $1}' FS="/" | tr "\n" " "`
Así podríamos avanzar más rápido, pero existe una alto riesgo de equivocarnos.

Referencias
Comandos de Advanced Packing Tool:

acción	Version antigua	Version moderna
instalar	apt-get install	apt install
desinstalar	apt-get remove	apt remove
desinstalar [1]	apt-get --purge remove	apt remove purge
mostrar detalles	apt-cache showpkg	apt show
Advanced Packing Tool: https://help.ubuntu.com/lts/serverguide/apt.html.en, https://geek-university.com/linux/advanced-packaging-tool-apt/.
Usando upgrade: https://help.ubuntu.com/lts/serverguide/installing-upgrading.html.en.
La nueva cara del APT: https://hipertextual.com/archivo/2014/04/nuevo-apt-ubuntu/.

============================================================================================================

			Problema de sonido con auriculares o altavoces

Cuando hay problemas de este tipo entrar en el panel del siguiente comando:

alsamixer

Luego presionar F6 para seleccionar la placa de sonido incorporada en la laptop, y posteriormente navegar con las flechas hasta llegar a la opción de 'speaker' y ajustar el volumen con las flechas
 
Presionar F6 y seleccionar la placa de audio que tiene la laptop o computadora incorporada, luego, navegar con las flechas del telado hacia la opción de speaker y subir el volumen con las flechas 

============================================================================================================

		Crear un servicio y gestionarlo para que inicie al enceder la máquina:

El script / binario / ejecutable
En este ejemplo vamos a suponer que necesitamos ejecutar un script que hemos colocado en /usr/local/bin/miscript.sh (nombre genérico)… por supuesto cada uno podrá adaptarlo a sus necesidades.

Cualquier archivo ejecutable, ya sea script o binario, vamos a poder cargarlo en nuestro sistema al momento de iniciar el sistema operativo.

Cable aclarar que se ejecutará al iniciar el sistema operativo, no el escritorio del usuario, por lo que si tienen la idea de arrancar Rambox o Firefox, o Pidgin al iniciar su sesión, este tutorial no les va ayudar! Para ello hay que cargar el ejecutable de la aplicación entre los iniciados automáticamente con la sesión de escritorio. Esto depende del entorno de escritorio que usen, pero en general está en el menú configuración -> Aplicaciones de Inicio, o Aplicaciones de sesión, o similar.

Por supuesto, el script o binario deberá tener permisos de ejecución, y para ellos podemos correr un comando similar a este:

sudo chmod +x /usr/local/bin/miscript.sh

Unidad de servicio systemd
Luego tenemos que crear una unidad de servicio systemd (systemd serivce unit).

Vamos a verlo funcionando con un ejemplo súper sencillo:

[Unit]
Description=<em class="replaceable">Mi script automatico</em>
After=network.target

[Service]
ExecStart=<em>/usr/local/bin/miscript.sh</em>
Type=oneshot
RemainAfterExit=true

[Install]
WantedBy=default.target


[Unit]
Description=<em class="replaceable">Mi script automatico</em>
After=network.target
 
[Service]
ExecStart=<em>/usr/local/bin/miscript.sh</em>
Type=oneshot
RemainAfterExit=true
 
[Install]
WantedBy=default.target
Donde:

Description: información descriptiva que es mostrada en el log de journal de systemd cuando ejecutamos «systemctl status servicio.service«
After: indica el servicio luego del cual correrá nuestro script. Supongamos que el script debe realizar algunas operaciones de red… sería lógico ejecutarlo luego de que se haya corrido network.service, cierto?
Se pueden agregar otros servicios separándolos por un espacio en blanco.
ExecStart: permite especificar la ruta completa al script que vamos a ejecutar, el nuestro.
Type: forking en este caso es utilizado por daemons o residentes para que realicen una clonación de la llamada al sistema. El proceso principal del servicio es creado con un pid especificado en el archivo de pid escrito a continuación.
WantedBy: especifica dentro de qué «target» de systemd debe ser instalado. Dejémoslo en default.target.
Sacando las opciones de Type, PIDFile y Description, esto es lo mínimo indispensable para poder ejecutar un script en systemd, las líneas mínimas para un service unit.

¿Que queremos más configuraciones y adaptaciones para nuestro entorno? Nada mejor que acercarse por la mesa de ayuda:

man systemd.service

Luego debemos darle permisos al nuevo archivo .service:

chmod 0644 /etc/systemd/system/miscript.service

Por cierto, luego de crear nuestra unidad de servicio, o de modificarla en el futuro, siempre debemos ejecutar el comando:

systemctl daemon-reload

Habilitando y ejecutando
Con estos pasos listos, ahora podremos habilitar el servicio con:

systemctl enable miscript.service

Y ejecutarlo con:

systemctl start miscript.service

Para otros comandos les recomiendo visitar SystemD vs SysVinit: algunos comandos.

Al estar habilitado / enabled, y al haberlo «instalado» en el target por defecto (default.target en la última línea del ejemplo), podremos ver su enlace simbólico en /etc/systemd/system/default.target.wants/

diego@cryptos:~/$ ls -l /etc/systemd/system/default.target.wants/
total 0
lrwxrwxrwx 1 root root 36 Mar 18 21:12 miscript.service -> /etc/systemd/system/miscript.service
1
2
3
diego@cryptos:~/$ ls -l /etc/systemd/system/default.target.wants/
total 0
lrwxrwxrwx 1 root root 36 Mar 18 21:12 miscript.service -> /etc/systemd/system/miscript.service
Y por supuesto, si ejecutamos:

systemctl disable miscript.service

Estaremos eliminando dicho enlace simbólico.

Esperamos les resulte interesante y útil!

A futuro ampliaremos esta información con otros parámetros que pueden ser de interés para iniciar y detener servicios residentes del segundo plano.


============================================================================================================


ESTO ES UNA PRUEBA A VER SI CAMBIA DE VERDAD

Esta es la segunda prueba es una computadora




